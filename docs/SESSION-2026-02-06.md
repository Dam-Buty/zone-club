# Session du 6 Février 2026 - Video Club WebGPU

## Objectif

Optimisation globale de la scène 3D pour atteindre **30 FPS sur MacBook Air M1 8GB** avec WebGPU, sans dégradation visuelle majeure.

---

## 1. Fix TV Click (Bug raycast)

**Probleme :** Cliquer sur l'ecran TV CRT ne declenchait pas le terminal.

**Cause racine :** Les meshes de texte overlay (idle, menu, playing) sont positionnes a `z=0.06`, **devant** la vitre CRT a `z=0.052`. Le raycast FPS touche le mesh le plus proche en premier. Ces overlays n'avaient pas `userData={{ isTVScreen: true }}`, donc le handler ne les reconnaissait pas comme ecran TV.

**Fix :** Ajout de `userData={{ isTVScreen: true }}` sur les 3 meshes overlay.

**Lecon :** En R3F avec raycast FPS, TOUS les meshes devant une surface interactive doivent porter le meme `userData` flag, pas seulement la surface cible.

**Fichier :** `src/components/interior/InteractiveTVDisplay.tsx`

---

## 2. Remplacement meshPhysicalMaterial → meshStandardMaterial

**Probleme :** `meshPhysicalMaterial` coute ~2x plus GPU que `meshStandardMaterial` (clearcoat, IOR, reflectivity calcules meme si non utilises).

**Objets migres :**
- Tubes neon plafond (`Lighting.tsx`)
- Texte neon 3D genre panels (`GenreSectionPanel.tsx`)
- TV CRT : corps, cadre, vitre, panneau controle, boutons, magnetoscope (`InteractiveTVDisplay.tsx`)

**Gain :** Elimination complete de meshPhysicalMaterial de la scene (0 restant).

---

## 3. Reduction segments geometriques

| Composant | Avant | Apres | Fichier |
|-----------|-------|-------|---------|
| Tubes neon plafond (cylindre) | 12 | 6 | `Lighting.tsx` |
| TV sphere CRT | 32 | 16 | `InteractiveTVDisplay.tsx` |
| TV boutons cylindres | 12 | 6 | `InteractiveTVDisplay.tsx` |
| Poubelle cylindre | 12 | 6 | `Aisle.tsx` |
| Bordure neon panels | 8 | 5 | `GenreSectionPanel.tsx` |
| Chaines suspension | 6 | 4 | `GenreSectionPanel.tsx` |
| Fixations coins | 8 | 5 | `GenreSectionPanel.tsx` |
| Yeux manager (iris) | 32 | 8 | `Manager3D.tsx` |
| Yeux manager (pupille) | 24 | 8 | `Manager3D.tsx` |
| Yeux manager (reflet) | 16 | 6 | `Manager3D.tsx` |
| Pieds canape | 12 | 6 | `Couch.tsx` |
| RoundedBox canape (×5) | smoothness=4 | smoothness=2 | `Couch.tsx` |

---

## 4. Fix artefacts Text3D police Caveat

**Probleme :** Le texte neon 3D (COMEDIE, HORREUR, etc.) apparaissait "decoupe" avec des trous.

**Cause racine :** La police manuscrite Caveat a des chemins de glyphes tres complexes (courbes multiples, intersections). La tessellation bevel de Three.js cree des triangles degeneres sur ces chemins → trous/artefacts visuels.

**Fix :** Suppression totale du bevel (`bevelEnabled={false}`), extrusion simple (`height=0.025`). L'effet neon vient de `emissive + bloom`, pas de la rondeur geometrique du mesh.

**Lecon :** Les polices manuscrites/handwritten sont incompatibles avec le bevel Three.js. Utiliser des polices geometriques (Helvetiker, Roboto) si le bevel est necessaire, sinon desactiver le bevel et compter sur emissive + bloom.

**Fichier :** `src/components/interior/GenreSectionPanel.tsx`

---

## 5. Strip font Caveat (97.9% reduction)

**Probleme :** La police caveat-bold.typeface.json contenait 753 glyphes (1367KB) alors que seuls 17 caracteres sont utilises (HORREUR, THRILLER, ACTION, COMEDIE, DRAME, NOUVEAUTES).

**Solution :** Script `scripts/strip-font.mjs` qui extrait uniquement les glyphes necessaires.

**Resultat :** 1367KB → 29KB (-97.9%)

**Lecon :** TOUJOURS stripper les fonts typeface.json aux seuls caracteres utilises. Le format JSON de Three.js inclut les contours vectoriels de chaque glyphe, ce qui est tres lourd pour les polices manuscrites.

---

## 6. Compression assets

### Images
| Fichier | Avant | Apres | Technique |
|---------|-------|-------|-----------|
| `outside.jpeg` | 9.9MB | 416KB | Resize 2048px + quality 70 |
| `storefront.jpeg` | 9.1MB | 475KB | Resize 2048px + quality 70 |
| `wall normal.jpg` | 2.2MB | 1.1MB | Quality 75 |
| `fabric normal.jpg` | 2.4MB | 1.2MB | Quality 75 |
| `floor normal.jpg` | 1.8MB | 594KB | Quality 75 |

### GLB (Draco compression via gltf-transform)
| Modele | Avant | Apres | Commande |
|--------|-------|-------|----------|
| `quentin_head.glb` | 24.2MB | 993KB | `gltf-transform optimize --compress draco` |
| `quentin_body.glb` | 474KB | 285KB | idem |
| `spot_light.glb` | 307KB | 29KB | idem |
| `pulp_fiction.glb` | 55KB | 3.1KB | idem |

**Important :** Activer Draco dans le code : `useGLTF(url, true)` (le 2e param `true` active le decodeur Draco via CDN drei).

### Assets supprimes (morts)
| Fichier | Taille | Raison |
|---------|--------|--------|
| `outside-mask.jpeg` | 13MB | Non reference |
| `storefront-mask-viz.png` | 7.7MB | Non reference |
| `outside-old.jpeg` | 8.1MB | Non reference |
| `helvetiker_bold.typeface.json` | 60KB | Remplace par Caveat |
| `quentin-cutted.png` | 1.2MB | Non reference |

---

## 7. Audit et suppression castShadow

Suppression de `castShadow` sur ~40 objets :

| Composant | Detail |
|-----------|--------|
| WallShelf | Planches individuelles |
| IslandShelf | Planches gauche + droite |
| Manager3D | Tete GLB (977K vertices) + corps |
| Couch | Base, dossier, accoudoirs, pieds, coussin (garde assise uniquement) |
| InteractiveTVDisplay | Meuble, plateau, corps TV |
| Aisle AsyncModel | Tous les enfants GLB |

**Lecon :** `castShadow` sur un modele GLB haute-poly genere un shadow map pour chaque vertex. Le manager (977K vertices) avec castShadow etait un des plus gros bottlenecks.

---

## 8. Textures TMDB w342 → w200

**Probleme :** 520 cassettes × texture w342 (~700KB GPU chacune) = ~350MB VRAM.

**Fix :** Passer a w200 + anisotropy 8→4.

**Gain estime :** ~200MB VRAM economises, chargement 2x plus rapide.

**Lecon :** Pour des objets de ~10cm dans une scene 3D, w200 (200px de large) est largement suffisant. w342 ne se justifie que pour des affichages plein ecran.

**Fichier :** `src/components/interior/Cassette.tsx`

---

## 9. Fix bloom inegal sur panneaux neon (couleurs sombres)

**Probleme :** Seuls les panneaux jaune (COMEDIE) et vert (HORREUR) emettaient un glow. Les autres (violet, rouge, orange, magenta) etaient eteints.

**Cause racine :** Le bloom utilise un seuil de **luminance perceptuelle** (`threshold=0.9`). La luminance se calcule : `L = 0.2126×R + 0.7152×G + 0.0722×B`. Avec `emissiveIntensity=1.5` :

| Couleur | Luminance × 1.5 | > 0.9 ? |
|---------|-----------------|---------|
| `#ffff00` jaune | 1.39 | OUI |
| `#00ff00` vert | 1.07 | OUI |
| `#ff6600` orange | 0.75 | NON |
| `#ff4444` rouge | 0.63 | NON |
| `#8844ff` violet | 0.56 | NON |
| `#ff00ff` magenta | 0.43 | NON |

**Fix :** Compensation d'intensite par luminance inverse :

```typescript
const neonIntensity = useMemo(() => {
  const c = new THREE.Color(color)
  const luminance = 0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b
  return THREE.MathUtils.clamp(1.3 / luminance, 1.3, 4.5)
}, [color])
```

Chaque couleur recoit une intensite compensee pour que `luminance × intensity ≈ 1.3` (au-dessus du seuil 0.9).

**Lecon cruciale :** Le bloom avec seuil de luminance discrimine les couleurs a basse luminance (violet, rouge, magenta). Il faut TOUJOURS compenser l'intensite emissive par l'inverse de la luminance si on veut un glow uniforme sur des couleurs variees.

**Fichier :** `src/components/interior/GenreSectionPanel.tsx`

---

## 10. Reduction bloom global

Le bloom creait un effet de flou general desagreable.

| Etape | Strength |
|-------|----------|
| Initial | 0.40 |
| Reduction -20% | 0.32 |
| Reduction -30% | 0.22 |
| Reduction -15% | **0.19** (final) |

**Lecon :** Le bloom WebGPU TSL est plus agressif visuellement que le bloom classique post-processing. Garder le strength bas (0.15-0.25) pour un effet subtil sans flou.

---

## Recapitulatif des gains

| Categorie | Avant | Apres | Gain |
|-----------|-------|-------|------|
| meshPhysicalMaterial | Nombreux | 0 | -100% |
| Assets disque | ~85MB | ~5MB | -94% |
| Textures GPU VRAM | ~350MB | ~150MB | -57% |
| Bloom strength | 0.40 | 0.19 | -52% |
| Vertices canape | ~35K | ~17K | -51% |
| Font size | 1367KB | 29KB | -97.9% |
| castShadow objects | ~40+ | ~5 | -87% |
| pointLights neon | 7 | 0 | -100% |
| Segments (moyenne) | 12-32 | 5-8 | -60% |

---

## Fichiers modifies

| Fichier | Modifications |
|---------|--------------|
| `GenreSectionPanel.tsx` | Font Caveat, no bevel, compensation luminance bloom, intensity prop |
| `InteractiveTVDisplay.tsx` | Fix TV click userData, Physical→Standard, segments reduits |
| `Lighting.tsx` | Neon tubes segments 12→6, Physical→Standard |
| `Manager3D.tsx` | Draco enabled, castShadow off, eye segments reduits |
| `Couch.tsx` | RoundedBox smoothness 4→2, pieds segments 12→6, castShadow off |
| `Cassette.tsx` | Posters w200, anisotropy 4 |
| `Aisle.tsx` | Draco GLB, castShadow off, segments reduits |
| `WallShelf.tsx` | castShadow off planches |
| `IslandShelf.tsx` | castShadow off planches |
| `PostProcessingEffects.tsx` | Bloom 0.40→0.19 |
| `public/fonts/caveat-bold.typeface.json` | Strip 753→17 glyphes |
| Assets publics | Compression images, GLB Draco, suppression fichiers morts |

---

## 11. Déduplication matériaux et géométries partagées

**Problème :** La scène créait des matériaux et géométries identiques inline dans le JSX. Chaque `<meshStandardMaterial>` dans une boucle crée un nouveau GPU material, même si les propriétés sont identiques.

**Solution :** Extraire les matériaux et géométries identiques comme constantes module-level ou useMemo partagés.

| Composant | Économie matériaux | Économie géométries |
|-----------|-------------------|-------------------|
| Lighting (NeonTube 9x) | -16 | -16 |
| GenreSectionPanel (5x) | -36 | -33 |
| GameBox/GameRack (32 boîtes) | -30 | -35 |
| WallShelf (planches/séparateurs) | -9/étagère | -1/étagère |
| IslandShelf (planches/structure) | -8 | -7 |
| Couch (tissu/bois/pieds) | -4 | — |
| Poster (cadre/verre) | -N×2 | — |
| **TOTAL** | **~120+** | **~90+** |

**Fichiers :** `Lighting.tsx`, `GenreSectionPanel.tsx`, `GameBox.tsx`, `WallShelf.tsx`, `IslandShelf.tsx`, `Couch.tsx`, `Poster.tsx`

---

## 12. Raycaster acceleration avec Three.js Layers

**Problème :** Le raycaster testait ~867 meshes chaque frame (tous les objets de la scène), alors que seuls ~526 sont interactifs.

**Solution :** Utiliser le système de layers Three.js :
- Layer 0 : géométrie statique (rendu uniquement, pas de raycast)
- Layer 1 : cassettes VHS (~521 meshes)
- Layer 2 : objets interactifs (manager, sonnette, TV : ~5 meshes)
- Raycaster configuré pour ne tester que layers 1+2

**Gain :** -39% d'objets testés par frame (867 → 526)

**Fichiers :** `Controls.tsx` (exports RAYCAST_LAYER_*), `Cassette.tsx`, `Manager3D.tsx`, `ServiceBell.tsx`, `InteractiveTVDisplay.tsx`

---

## 13. Consolidation useFrame cassettes (521 → 1)

**Problème :** Chaque cassette avait son propre callback `useFrame` + souscription Zustand, soit ~521 callbacks R3F et ~521 souscriptions au store exécutées par frame.

**Solution :** Système d'animation centralisé (`CassetteAnimationSystem.ts`) :
- Registry Map<cassetteKey, AnimData> où chaque cassette s'inscrit au mount
- UN SEUL useFrame dans `CassetteAnimationLoop.tsx` itère le registry
- Le store Zustand est lu UNE FOIS par frame via `getState()` (pas de souscription React)
- Frustum culling, throttle, hystérésis identiques mais en batch

**Gain :** -520 callbacks useFrame, -521 souscriptions Zustand

**Fichiers :** `CassetteAnimationSystem.ts` (nouveau), `CassetteAnimationLoop.tsx` (nouveau), `Cassette.tsx` (refactoré), `InteriorScene.tsx`

---

## 14. SSAO (GTAO) + FXAA post-processing

**Ajout :** Pipeline post-processing enrichi pour photoréalisme :
- **GTAO** (Ground Truth Ambient Occlusion) : ombres de contact subtiles dans les coins et entre objets proches. Essentiel pour crédibilité d'une scène intérieure.
  - `scale=0.5` (intensité subtile), `radius=0.25` (~25cm), `thickness=1.0`
- **FXAA** (Fast Approximate Anti-Aliasing) : lisse les bords crénelés sans coût MSAA
- **MRT** (Multiple Render Targets) activé pour fournir normales + depth au GTAO

Pipeline final : **Scene MRT → GTAO → Bloom → Vignette → FXAA → Output**

**Fichier :** `PostProcessingEffects.tsx`
