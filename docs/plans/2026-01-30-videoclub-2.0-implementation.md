# VideoClub 2.0 - Implementation Plan

## R√àGLES OBLIGATOIRES - PROJET 3D

**AVANT de coder:**
1. √âtudier l'image de r√©f√©rence pixel par pixel
2. Rechercher l'√©tat de l'art (pas d'improvisation!)
3. Utiliser les outils existants (NeonTube.ts, TextureLoader, etc.)
4. V√©rifier visuellement CHAQUE modification

**INTERDIT:** Bo√Ætes par paresse, suppositions, marquer "compl√©t√©" sans v√©rification visuelle.

---

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build an immersive 80s-themed virtual video rental store with WebGPU 3D browsing, VHS player, and passionate manager character.

**Architecture:** React 18 + TypeScript frontend with Zustand state management. WebGPU handles 3D rendering (entrance + aisle scenes). TMDB API for film metadata. Self-hosted video files. LocalStorage for persistence.

**Tech Stack:** Vite 7+, React 19, TypeScript, Zustand, Tailwind CSS 4.0, WebGPU (WGSL shaders), TMDB API

---

## Phase 1: Project Setup

### Task 1: Initialize Vite 7 + React 19 + TypeScript

**Step 1: Create project with Vite 7**
```bash
cd /Users/rusmirsadikovic/projetsperso/video-club-webgpu
npm create vite@latest . -- --template react-ts
```

**Step 2: Upgrade to React 19**
```bash
npm install react@19 react-dom@19
npm install -D @types/react@19 @types/react-dom@19
```

**Step 3: Install and verify**
```bash
npm install
npm run dev
```
Expected: Dev server runs at localhost:5173

**Step 4: Commit**
```bash
git add -A && git commit -m "chore: initialize vite 7 + react 19 project"
```

---

### Task 2: Install dependencies + Tailwind 4.0

**Step 1: Install runtime dependencies**
```bash
npm install zustand @tanstack/react-query
```

**Step 2: Install Tailwind CSS 4.0**
```bash
npm install tailwindcss @tailwindcss/vite
```

**Step 3: Configure Vite for Tailwind 4**

Update `vite.config.ts`:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [react(), tailwindcss()],
})
```

**Step 4: Setup Tailwind in CSS**

Replace `src/index.css`:
```css
@import "tailwindcss";
```

**Step 5: Install dev dependencies**
```bash
npm install -D @types/webgpu
```

**Step 6: Commit**
```bash
git add -A && git commit -m "chore: add zustand, react-query, tailwind 4.0, webgpu types"
```

---

### Task 3: Setup project structure

**Files to create:**
- `src/types/index.ts`
- `src/store/index.ts`
- `src/services/tmdb.ts`
- `src/services/storage.ts`
- `src/services/manager.ts`
- `src/hooks/useWebGPU.ts`
- `src/data/mock/films.json`
- `src/data/mock/manager-responses.json`
- `src/data/mock/videos-mapping.json`
- `src/webgpu/core/Renderer.ts`
- `src/styles/variables.css`

**Step 1: Create directory structure**
```bash
mkdir -p src/{types,store,services,hooks,data/mock,webgpu/{core,shaders,scenes,objects},components/{ui,videoclub,manager,player},styles}
```

**Step 2: Create placeholder files**
```bash
touch src/types/index.ts src/store/index.ts
touch src/services/{tmdb,storage,manager}.ts
touch src/hooks/useWebGPU.ts
touch src/data/mock/{films,manager-responses,videos-mapping}.json
touch src/webgpu/core/Renderer.ts
touch src/styles/variables.css
```

**Step 3: Commit**
```bash
git add -A && git commit -m "chore: setup project directory structure"
```

---

### Task 4: Setup Tailwind 4.0 theme and CSS variables

**File:** `src/index.css`

**Step 1: Configure Tailwind 4.0 with custom theme**
```css
@import "tailwindcss";
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;500;600&display=swap');

@theme {
  /* Neon Colors */
  --color-neon-pink: #ff2d95;
  --color-neon-cyan: #00fff7;
  --color-neon-purple: #b026ff;
  --color-neon-yellow: #fff600;

  /* Backgrounds */
  --color-dark-bg: #0a0a0f;
  --color-darker-bg: #050508;
  --color-card-bg: rgba(20, 20, 30, 0.8);

  /* Typography */
  --font-display: 'Orbitron', sans-serif;
  --font-body: 'Inter', sans-serif;
}

/* Glow utilities via CSS variables */
:root {
  --glow-pink: 0 0 10px #ff2d95, 0 0 20px #ff2d95, 0 0 40px #ff2d95;
  --glow-cyan: 0 0 10px #00fff7, 0 0 20px #00fff7, 0 0 40px #00fff7;
  --glow-purple: 0 0 10px #b026ff, 0 0 20px #b026ff, 0 0 40px #b026ff;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-body);
  background: var(--color-darker-bg);
  color: white;
  overflow: hidden;
}

/* Custom glow utilities */
.glow-pink { box-shadow: var(--glow-pink); }
.glow-cyan { box-shadow: var(--glow-cyan); }
.glow-purple { box-shadow: var(--glow-purple); }
.text-glow-pink { text-shadow: var(--glow-pink); }
.text-glow-cyan { text-shadow: var(--glow-cyan); }
.text-glow-purple { text-shadow: var(--glow-purple); }
```

**Step 2: Update main.tsx for React 19**

Replace `src/main.tsx`:
```tsx
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(<App />)
```

Note: React 19 no longer requires StrictMode wrapper by default, and uses the new createRoot API directly.

**Step 3: Commit**
```bash
git add src/index.css src/main.tsx && git commit -m "feat: configure tailwind 4.0 theme with neon colors"
```

---

## Phase 2: Types and Core Services

### Task 5: Define TypeScript types

**File:** `src/types/index.ts`

**Step 1: Write types**
```typescript
// Film types
export interface Film {
  id: number;
  title: string;
  overview: string;
  poster_path: string | null;
  backdrop_path: string | null;
  release_date: string;
  runtime: number | null;
  vote_average: number;
  genres: Genre[];
}

export interface Genre {
  id: number;
  name: string;
}

export type AisleType = 'nouveautes' | 'action' | 'horreur' | 'sf' | 'comedie' | 'classiques' | 'bizarre';

// Rental types
export interface Rental {
  filmId: number;
  rentedAt: number; // timestamp
  expiresAt: number; // timestamp
  videoUrl: string;
}

export type RentalTier = 'standard' | 'nouveaute' | 'classique';

export const RENTAL_COSTS: Record<RentalTier, number> = {
  standard: 1,
  nouveaute: 2,
  classique: 1,
};

export const RENTAL_DURATIONS: Record<RentalTier, number> = {
  standard: 72 * 60 * 60 * 1000,    // 72h
  nouveaute: 48 * 60 * 60 * 1000,   // 48h
  classique: 7 * 24 * 60 * 60 * 1000, // 1 week
};

// User types
export type MemberLevel = 'bronze' | 'argent' | 'or' | 'platine';

export interface User {
  credits: number;
  totalRentals: number;
  level: MemberLevel;
  badges: string[];
}

// Manager types
export type ManagerTrigger = 'HOVER_LONG' | 'HESITATION' | 'GENRE_RETURN' | 'POST_RENTAL' | 'BELL_CLICK';

export interface ManagerResponse {
  text: string;
  filmId?: number;
}

export interface FilmAnecdote {
  anecdotes: string[];
  suggestion?: {
    filmId: number;
    reason: string;
  };
}

// Scene types
export type SceneType = 'entrance' | 'aisle';

// Player types
export type PlayerState = 'playing' | 'paused' | 'seeking' | 'rewinding' | 'fastforwarding';
```

**Step 2: Commit**
```bash
git add src/types/index.ts && git commit -m "feat: define TypeScript types for films, rentals, user, manager"
```

---

### Task 6: Create Zustand store

**File:** `src/store/index.ts`

**Step 1: Write store**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Film, Rental, User, AisleType, SceneType, MemberLevel } from '../types';

function calculateLevel(totalRentals: number): MemberLevel {
  if (totalRentals >= 50) return 'platine';
  if (totalRentals >= 25) return 'or';
  if (totalRentals >= 10) return 'argent';
  return 'bronze';
}

interface VideoClubState {
  // User
  user: User;
  addCredits: (amount: number) => void;
  deductCredits: (amount: number) => boolean;

  // Rentals
  rentals: Rental[];
  addRental: (rental: Rental) => void;
  removeRental: (filmId: number) => void;
  getRental: (filmId: number) => Rental | undefined;

  // Scene
  currentScene: SceneType;
  currentAisle: AisleType;
  selectedFilmId: number | null;
  setScene: (scene: SceneType) => void;
  setAisle: (aisle: AisleType) => void;
  selectFilm: (filmId: number | null) => void;

  // Films cache
  films: Record<AisleType, Film[]>;
  setFilmsForAisle: (aisle: AisleType, films: Film[]) => void;

  // Manager
  managerVisible: boolean;
  chatHistory: { role: 'manager' | 'user'; text: string }[];
  lastBonusDate: string | null;
  showManager: () => void;
  hideManager: () => void;
  addChatMessage: (role: 'manager' | 'user', text: string) => void;
  clearChat: () => void;
  claimDailyBonus: () => boolean;

  // Player
  isPlayerOpen: boolean;
  currentPlayingFilm: number | null;
  openPlayer: (filmId: number) => void;
  closePlayer: () => void;
}

export const useStore = create<VideoClubState>()(
  persist(
    (set, get) => ({
      // User - initial 5 credits
      user: {
        credits: 5,
        totalRentals: 0,
        level: 'bronze',
        badges: [],
      },
      addCredits: (amount) =>
        set((state) => ({
          user: { ...state.user, credits: state.user.credits + amount },
        })),
      deductCredits: (amount) => {
        const { user } = get();
        if (user.credits < amount) return false;
        set((state) => ({
          user: { ...state.user, credits: state.user.credits - amount },
        }));
        return true;
      },

      // Rentals
      rentals: [],
      addRental: (rental) =>
        set((state) => {
          const newTotalRentals = state.user.totalRentals + 1;
          return {
            rentals: [...state.rentals, rental],
            user: {
              ...state.user,
              totalRentals: newTotalRentals,
              level: calculateLevel(newTotalRentals),
            },
          };
        }),
      removeRental: (filmId) =>
        set((state) => ({
          rentals: state.rentals.filter((r) => r.filmId !== filmId),
        })),
      getRental: (filmId) => get().rentals.find((r) => r.filmId === filmId),

      // Scene
      currentScene: 'entrance',
      currentAisle: 'nouveautes',
      selectedFilmId: null,
      setScene: (scene) => set({ currentScene: scene }),
      setAisle: (aisle) => set({ currentAisle: aisle }),
      selectFilm: (filmId) => set({ selectedFilmId: filmId }),

      // Films cache
      films: {
        nouveautes: [],
        action: [],
        horreur: [],
        sf: [],
        comedie: [],
        classiques: [],
        bizarre: [],
      },
      setFilmsForAisle: (aisle, films) =>
        set((state) => ({
          films: { ...state.films, [aisle]: films },
        })),

      // Manager
      managerVisible: false,
      chatHistory: [],
      lastBonusDate: null,
      showManager: () => set({ managerVisible: true }),
      hideManager: () => set({ managerVisible: false }),
      addChatMessage: (role, text) =>
        set((state) => ({
          chatHistory: [...state.chatHistory, { role, text }],
        })),
      clearChat: () => set({ chatHistory: [] }),
      claimDailyBonus: () => {
        const today = new Date().toDateString();
        const { lastBonusDate, chatHistory } = get();
        if (lastBonusDate === today) return false;
        if (chatHistory.length < 6) return false; // 3+ exchanges = 6 messages
        set((state) => ({
          lastBonusDate: today,
          user: { ...state.user, credits: state.user.credits + 1 },
        }));
        return true;
      },

      // Player
      isPlayerOpen: false,
      currentPlayingFilm: null,
      openPlayer: (filmId) => set({ isPlayerOpen: true, currentPlayingFilm: filmId }),
      closePlayer: () => set({ isPlayerOpen: false, currentPlayingFilm: null }),
    }),
    {
      name: 'videoclub-storage',
      partialize: (state) => ({
        user: state.user,
        rentals: state.rentals,
        lastBonusDate: state.lastBonusDate,
      }),
    }
  )
);
```

**Step 2: Commit**
```bash
git add src/store/index.ts && git commit -m "feat: create Zustand store with user, rentals, scene, manager state"
```

---

### Task 7: Create TMDB service

**File:** `src/services/tmdb.ts`

**Step 1: Write service**
```typescript
import type { Film } from '../types';

const API_KEY = import.meta.env.VITE_TMDB_API_KEY;
const BASE_URL = 'https://api.themoviedb.org/3';
const IMAGE_BASE = 'https://image.tmdb.org/t/p';

export const tmdb = {
  posterUrl: (path: string | null, size: 'w342' | 'w500' | 'original' = 'w500') =>
    path ? `${IMAGE_BASE}/${size}${path}` : '/placeholder-poster.jpg',

  backdropUrl: (path: string | null, size: 'w780' | 'w1280' | 'original' = 'w1280') =>
    path ? `${IMAGE_BASE}/${size}${path}` : null,

  async getFilm(id: number): Promise<Film> {
    const res = await fetch(
      `${BASE_URL}/movie/${id}?api_key=${API_KEY}&language=fr-FR`
    );
    if (!res.ok) throw new Error(`TMDB error: ${res.status}`);
    return res.json();
  },

  async getFilms(ids: number[]): Promise<Film[]> {
    const results = await Promise.all(
      ids.map((id) => this.getFilm(id).catch(() => null))
    );
    return results.filter((f): f is Film => f !== null);
  },
};
```

**Step 2: Create .env.example**

**File:** `.env.example`
```
VITE_TMDB_API_KEY=your_tmdb_api_key_here
```

**Step 3: Add .env to .gitignore**

**File:** `.gitignore` (append)
```
.env
.env.local
```

**Step 4: Commit**
```bash
git add src/services/tmdb.ts .env.example .gitignore && git commit -m "feat: add TMDB service for fetching film data"
```

---

### Task 8: Create mock data files

**File:** `src/data/mock/films.json`

**Step 1: Write films mock**
```json
{
  "nouveautes": [550, 238, 424, 155, 680],
  "action": [27205, 155, 78, 102899, 324857],
  "horreur": [694, 539, 1091, 565, 493922],
  "sf": [603, 157336, 274, 264660, 335984],
  "comedie": [18785, 109445, 508442, 4011, 22538],
  "classiques": [238, 240, 278, 389, 769],
  "bizarre": [1051896, 10681, 9426, 185, 77]
}
```

**File:** `src/data/mock/manager-responses.json`

**Step 2: Write manager responses**
```json
{
  "greeting": [
    "Ah, te revoil√†. Je commen√ßais √† m'ennuyer.",
    "Bienvenue dans mon antre. T'as l'air de quelqu'un qui sait ce qu'il veut.",
    "Ouais ? Qu'est-ce que je peux faire pour toi ?"
  ],
  "films": {
    "550": {
      "anecdotes": [
        "Fight Club. FIGHT CLUB. Tu sais que Fincher a failli tout plaquer sur ce film ? Le studio comprenait RIEN. Et c'est devenu culte. C'est beau, non ?",
        "La sc√®ne du bus, mec. Pitt s'est vraiment fait frapper. VRAIMENT. M√©thode acting pouss√© √† l'extr√™me."
      ],
      "suggestion": {
        "filmId": 807,
        "reason": "Si t'aimes Fight Club, faut que tu voies Se7en. M√™me Fincher, m√™me ambiance poisseuse, m√™me Brad Pitt qui en prend plein la gueule."
      }
    },
    "238": {
      "anecdotes": [
        "Le Parrain. LE PARRAIN. Coppola a d√ª se battre pour garder Brando. Le studio voulait pas de lui. Tu imagines Le Parrain sans Brando ?",
        "La sc√®ne du chat, tu sais qu'il √©tait pas pr√©vu ? Le chat s'est juste pos√© sur les genoux de Brando et ils ont gard√© la prise. G√âNIE."
      ],
      "suggestion": {
        "filmId": 240,
        "reason": "Tu vas encha√Æner avec Le Parrain 2, hein ? Parce que sinon on peut plus √™tre amis."
      }
    },
    "603": {
      "anecdotes": [
        "Matrix. Les Wachowski ont invent√© le bullet time pour CE film. Tout le monde a copi√© apr√®s. TOUT LE MONDE.",
        "Tu sais que Keanu a donn√© une partie de son salaire √† l'√©quipe des effets sp√©ciaux ? Classe totale."
      ],
      "suggestion": {
        "filmId": 157336,
        "reason": "Si t'aimes Matrix, Interstellar va te retourner le cerveau. C'est de la SF qui pose les vraies questions."
      }
    }
  },
  "aisles": {
    "nouveautes": "Les nouveaut√©s. Toujours int√©ressant de voir ce qui sort. Mais entre nous, les vrais films, c'est pas toujours l√† qu'on les trouve.",
    "action": "Ah, l'action. Du spectacle, de l'adr√©naline. Mais attention, y'a action et ACTION. Je peux te guider si tu veux.",
    "horreur": "Un amateur de sensations fortes. Respect. L'horreur c'est un art, pas juste des jump scares.",
    "sf": "La SF, c'est pas que des lasers et des vaisseaux. C'est de la philosophie avec des effets sp√©ciaux. Les vrais savent.",
    "comedie": "La com√©die, c'est le plus dur √† r√©ussir. Faire rire, vraiment rire, c'est un talent rare.",
    "classiques": "Ah, les classiques. L√† on parle. Le VRAI cin√©ma. Respect.",
    "bizarre": "Le Coin Bizarre... Tu t'aventures en territoire inconnu. J'aime √ßa. T'es pr√™t pour l'√©trange ?"
  },
  "rentalReactions": {
    "positive": [
      "Excellent choix. T'as du go√ªt.",
      "Ah ! Enfin quelqu'un qui comprend. Profite bien.",
      "Tu vas pas √™tre d√©√ßu. Reviens me dire ce que t'en as pens√©."
    ],
    "neutral": [
      "OK, pourquoi pas. Y'a des trucs int√©ressants dedans.",
      "C'est un choix. Pas le mien, mais c'est ton choix."
    ],
    "negative": [
      "Bon... c'est ton choix. Moi j'aurais pris autre chose mais... non, vas-y, regarde-le. On en reparle apr√®s.",
      "Vraiment ? Celui-l√† ? ... OK, OK, je dis rien. Chacun son truc."
    ]
  }
}
```

**File:** `src/data/mock/videos-mapping.json`

**Step 3: Write videos mapping**
```json
{
  "550": "/videos/fight-club.mp4",
  "238": "/videos/godfather.mp4",
  "603": "/videos/matrix.mp4",
  "155": "/videos/dark-knight.mp4",
  "157336": "/videos/interstellar.mp4"
}
```

**Step 4: Commit**
```bash
git add src/data/mock/*.json && git commit -m "feat: add mock data for films, manager responses, video mappings"
```

---

## Phase 3: WebGPU Core

### Task 9: Create WebGPU initialization hook

**File:** `src/hooks/useWebGPU.ts`

**Step 1: Write hook**
```typescript
import { useEffect, useRef, useState } from 'react';

interface WebGPUContext {
  device: GPUDevice;
  context: GPUCanvasContext;
  format: GPUTextureFormat;
  canvas: HTMLCanvasElement;
}

export function useWebGPU(canvasRef: React.RefObject<HTMLCanvasElement>) {
  const [gpuContext, setGpuContext] = useState<WebGPUContext | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    async function initWebGPU() {
      const canvas = canvasRef.current;
      if (!canvas) {
        setError('Canvas not found');
        setIsLoading(false);
        return;
      }

      if (!navigator.gpu) {
        setError('WebGPU not supported in this browser');
        setIsLoading(false);
        return;
      }

      try {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          setError('No GPU adapter found');
          setIsLoading(false);
          return;
        }

        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        if (!context) {
          setError('Could not get WebGPU context');
          setIsLoading(false);
          return;
        }

        const format = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device,
          format,
          alphaMode: 'premultiplied',
        });

        setGpuContext({ device, context, format, canvas });
        setIsLoading(false);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'WebGPU initialization failed');
        setIsLoading(false);
      }
    }

    initWebGPU();
  }, [canvasRef]);

  return { gpuContext, error, isLoading };
}
```

**Step 2: Commit**
```bash
git add src/hooks/useWebGPU.ts && git commit -m "feat: add useWebGPU hook for WebGPU initialization"
```

---

### Task 10: Create basic WGSL shader

**File:** `src/webgpu/shaders/basic.wgsl`

**Step 1: Write shader**
```wgsl
struct Uniforms {
  modelViewProjection: mat4x4f,
  time: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var textureSampler: sampler;
@group(0) @binding(2) var textureData: texture_2d<f32>;

struct VertexInput {
  @location(0) position: vec3f,
  @location(1) uv: vec2f,
  @location(2) normal: vec3f,
}

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) normal: vec3f,
}

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
  var output: VertexOutput;
  output.position = uniforms.modelViewProjection * vec4f(input.position, 1.0);
  output.uv = input.uv;
  output.normal = input.normal;
  return output;
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let texColor = textureSample(textureData, textureSampler, input.uv);
  return texColor;
}
```

**Step 2: Commit**
```bash
git add src/webgpu/shaders/basic.wgsl && git commit -m "feat: add basic WGSL shader for textured geometry"
```

---

### Task 11: Create neon glow shader

**File:** `src/webgpu/shaders/neon.wgsl`

**Step 1: Write shader**
```wgsl
struct Uniforms {
  resolution: vec2f,
  time: f32,
  glowIntensity: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var inputTexture: texture_2d<f32>;
@group(0) @binding(2) var inputSampler: sampler;

@vertex
fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
  // Full-screen quad
  var positions = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f(1.0, -1.0),
    vec2f(-1.0, 1.0),
    vec2f(-1.0, 1.0),
    vec2f(1.0, -1.0),
    vec2f(1.0, 1.0)
  );
  return vec4f(positions[vertexIndex], 0.0, 1.0);
}

@fragment
fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
  let uv = fragCoord.xy / uniforms.resolution;
  let texColor = textureSample(inputTexture, inputSampler, uv);

  // Detect bright pixels (neon sources)
  let brightness = max(texColor.r, max(texColor.g, texColor.b));

  // Apply bloom to bright areas
  var bloom = vec4f(0.0);
  let blurSize = 0.003 * uniforms.glowIntensity;

  for (var i = -2; i <= 2; i++) {
    for (var j = -2; j <= 2; j++) {
      let offset = vec2f(f32(i), f32(j)) * blurSize;
      let sample = textureSample(inputTexture, inputSampler, uv + offset);
      let sampleBrightness = max(sample.r, max(sample.g, sample.b));
      if (sampleBrightness > 0.7) {
        bloom += sample;
      }
    }
  }
  bloom /= 25.0;

  // Combine original with bloom
  let result = texColor + bloom * uniforms.glowIntensity;
  return vec4f(result.rgb, 1.0);
}
```

**Step 2: Commit**
```bash
git add src/webgpu/shaders/neon.wgsl && git commit -m "feat: add neon glow post-processing shader"
```

---

### Task 12: Create VHS effect shader

**File:** `src/webgpu/shaders/vhs.wgsl`

**Step 1: Write shader**
```wgsl
struct Uniforms {
  resolution: vec2f,
  time: f32,
  grainIntensity: f32,
  scanlineIntensity: f32,
  trackingEnabled: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var inputTexture: texture_2d<f32>;
@group(0) @binding(2) var inputSampler: sampler;

fn rand(co: vec2f) -> f32 {
  return fract(sin(dot(co, vec2f(12.9898, 78.233))) * 43758.5453);
}

@vertex
fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
  var positions = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f(1.0, -1.0),
    vec2f(-1.0, 1.0),
    vec2f(-1.0, 1.0),
    vec2f(1.0, -1.0),
    vec2f(1.0, 1.0)
  );
  return vec4f(positions[vertexIndex], 0.0, 1.0);
}

@fragment
fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
  var uv = fragCoord.xy / uniforms.resolution;

  // Tracking distortion (when enabled)
  if (uniforms.trackingEnabled > 0.5) {
    let trackingLine = step(0.98, fract(uv.y * 20.0 + uniforms.time * 2.0));
    uv.x += trackingLine * 0.02 * sin(uniforms.time * 10.0);
  }

  var color = textureSample(inputTexture, inputSampler, uv);

  // Scanlines
  let scanline = sin(fragCoord.y * 2.0) * 0.5 + 0.5;
  color = mix(color, color * scanline, uniforms.scanlineIntensity * 0.3);

  // Film grain
  let grain = rand(uv + vec2f(uniforms.time, 0.0)) - 0.5;
  color += vec4f(vec3f(grain * uniforms.grainIntensity * 0.1), 0.0);

  // Slight chromatic aberration
  let caOffset = 0.001;
  let r = textureSample(inputTexture, inputSampler, uv + vec2f(caOffset, 0.0)).r;
  let b = textureSample(inputTexture, inputSampler, uv - vec2f(caOffset, 0.0)).b;
  color.r = r;
  color.b = b;

  // Vignette
  let vignette = 1.0 - smoothstep(0.5, 1.5, length(uv - 0.5) * 1.5);
  color *= vignette;

  return vec4f(color.rgb, 1.0);
}
```

**Step 2: Commit**
```bash
git add src/webgpu/shaders/vhs.wgsl && git commit -m "feat: add VHS post-processing shader with grain, scanlines, tracking"
```

---

## Phase 4: WebGPU Renderer Core

### Task 13: Create Renderer class

**File:** `src/webgpu/core/Renderer.ts`

**Step 1: Write renderer**
```typescript
import basicShaderCode from '../shaders/basic.wgsl?raw';
import neonShaderCode from '../shaders/neon.wgsl?raw';
import vhsShaderCode from '../shaders/vhs.wgsl?raw';

export interface RenderObject {
  vertexBuffer: GPUBuffer;
  indexBuffer: GPUBuffer;
  indexCount: number;
  texture: GPUTexture;
  modelMatrix: Float32Array;
}

export class Renderer {
  private device: GPUDevice;
  private context: GPUCanvasContext;
  private format: GPUTextureFormat;

  private basicPipeline!: GPURenderPipeline;
  private neonPipeline!: GPURenderPipeline;
  private vhsPipeline!: GPURenderPipeline;

  private uniformBuffer!: GPUBuffer;
  private sampler!: GPUSampler;

  private renderTexture!: GPUTexture;
  private renderTextureView!: GPUTextureView;

  private startTime = Date.now();

  constructor(device: GPUDevice, context: GPUCanvasContext, format: GPUTextureFormat) {
    this.device = device;
    this.context = context;
    this.format = format;
    this.initialize();
  }

  private initialize() {
    // Create sampler
    this.sampler = this.device.createSampler({
      magFilter: 'linear',
      minFilter: 'linear',
      mipmapFilter: 'linear',
    });

    // Create uniform buffer
    this.uniformBuffer = this.device.createBuffer({
      size: 256, // Enough for matrices and uniforms
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    // Create render texture for post-processing
    this.createRenderTexture();

    // Create pipelines
    this.createBasicPipeline();
    this.createPostProcessPipelines();
  }

  private createRenderTexture() {
    const canvas = this.context.canvas as HTMLCanvasElement;
    this.renderTexture = this.device.createTexture({
      size: [canvas.width, canvas.height],
      format: this.format,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    });
    this.renderTextureView = this.renderTexture.createView();
  }

  private createBasicPipeline() {
    const shaderModule = this.device.createShaderModule({
      code: basicShaderCode,
    });

    this.basicPipeline = this.device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: shaderModule,
        entryPoint: 'vertexMain',
        buffers: [{
          arrayStride: 32, // 3 pos + 2 uv + 3 normal = 8 floats
          attributes: [
            { shaderLocation: 0, offset: 0, format: 'float32x3' },
            { shaderLocation: 1, offset: 12, format: 'float32x2' },
            { shaderLocation: 2, offset: 20, format: 'float32x3' },
          ],
        }],
      },
      fragment: {
        module: shaderModule,
        entryPoint: 'fragmentMain',
        targets: [{ format: this.format }],
      },
      primitive: {
        topology: 'triangle-list',
        cullMode: 'back',
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        format: 'depth24plus',
      },
    });
  }

  private createPostProcessPipelines() {
    // Neon glow pipeline
    const neonModule = this.device.createShaderModule({ code: neonShaderCode });
    this.neonPipeline = this.device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: neonModule, entryPoint: 'vertexMain' },
      fragment: {
        module: neonModule,
        entryPoint: 'fragmentMain',
        targets: [{ format: this.format }],
      },
    });

    // VHS effect pipeline
    const vhsModule = this.device.createShaderModule({ code: vhsShaderCode });
    this.vhsPipeline = this.device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: vhsModule, entryPoint: 'vertexMain' },
      fragment: {
        module: vhsModule,
        entryPoint: 'fragmentMain',
        targets: [{ format: this.format }],
      },
    });
  }

  resize(width: number, height: number) {
    this.renderTexture.destroy();
    this.createRenderTexture();
  }

  getTime(): number {
    return (Date.now() - this.startTime) / 1000;
  }

  get deviceRef(): GPUDevice {
    return this.device;
  }

  get samplerRef(): GPUSampler {
    return this.sampler;
  }
}
```

**Step 2: Commit**
```bash
git add src/webgpu/core/Renderer.ts && git commit -m "feat: create WebGPU Renderer class with basic and post-process pipelines"
```

---

## Phase 5: React UI Components

### Task 14: Create Header component

**File:** `src/components/ui/Header.tsx`

**Step 1: Write component**
```tsx
import { useStore } from '../../store';
import styles from './Header.module.css';

export function Header() {
  const { user, showManager } = useStore();

  return (
    <header className={styles.header}>
      <div className={styles.logo}>
        <span className={styles.logoText}>VIDEO</span>
        <span className={styles.logoAccent}>CLUB</span>
      </div>

      <div className={styles.right}>
        <div className={styles.credits}>
          <span className={styles.creditsLabel}>CR√âDITS</span>
          <span className={styles.creditsValue}>{user.credits}</span>
        </div>

        <div className={styles.memberCard}>
          <span className={styles.level}>{user.level.toUpperCase()}</span>
        </div>

        <button className={styles.bell} onClick={showManager} aria-label="Appeler le g√©rant">
          üîî
        </button>
      </div>
    </header>
  );
}
```

**File:** `src/components/ui/Header.module.css`

**Step 2: Write styles**
```css
.header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 var(--space-lg);
  background: linear-gradient(180deg, rgba(10, 10, 15, 0.95) 0%, rgba(10, 10, 15, 0.8) 100%);
  border-bottom: 1px solid rgba(255, 45, 149, 0.3);
  z-index: 100;
}

.logo {
  font-family: var(--font-display);
  font-size: 1.5rem;
  font-weight: 900;
  letter-spacing: 0.1em;
}

.logoText {
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
}

.logoAccent {
  color: var(--neon-pink);
  text-shadow: var(--glow-pink);
  margin-left: 0.25em;
}

.right {
  display: flex;
  align-items: center;
  gap: var(--space-lg);
}

.credits {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.creditsLabel {
  font-size: 0.6rem;
  color: rgba(255, 255, 255, 0.5);
  letter-spacing: 0.1em;
}

.creditsValue {
  font-family: var(--font-display);
  font-size: 1.25rem;
  color: var(--neon-yellow);
  text-shadow: 0 0 10px var(--neon-yellow);
}

.memberCard {
  padding: var(--space-xs) var(--space-md);
  border: 1px solid var(--neon-purple);
  border-radius: 4px;
}

.level {
  font-family: var(--font-display);
  font-size: 0.75rem;
  color: var(--neon-purple);
  letter-spacing: 0.1em;
}

.bell {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  transition: transform var(--transition-fast);
  filter: drop-shadow(0 0 5px var(--neon-yellow));
}

.bell:hover {
  transform: scale(1.1) rotate(15deg);
}

.bell:active {
  transform: scale(0.95);
}
```

**Step 3: Commit**
```bash
git add src/components/ui/Header.tsx src/components/ui/Header.module.css && git commit -m "feat: create Header component with logo, credits, member level, bell"
```

---

### Task 15: Create Modal component

**File:** `src/components/ui/Modal.tsx`

**Step 1: Write component**
```tsx
import { useEffect, useRef, type ReactNode } from 'react';
import styles from './Modal.module.css';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: ReactNode;
  title?: string;
}

export function Modal({ isOpen, onClose, children, title }: ModalProps) {
  const overlayRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const handleOverlayClick = (e: React.MouseEvent) => {
    if (e.target === overlayRef.current) onClose();
  };

  return (
    <div className={styles.overlay} ref={overlayRef} onClick={handleOverlayClick}>
      <div className={styles.modal}>
        <button className={styles.closeButton} onClick={onClose} aria-label="Fermer">
          ‚úï
        </button>
        {title && <h2 className={styles.title}>{title}</h2>}
        <div className={styles.content}>{children}</div>
      </div>
    </div>
  );
}
```

**File:** `src/components/ui/Modal.module.css`

**Step 2: Write styles**
```css
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 200;
  animation: fadeIn 200ms ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal {
  position: relative;
  background: var(--card-bg);
  border: 1px solid var(--neon-pink);
  border-radius: 8px;
  padding: var(--space-xl);
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--glow-pink), 0 25px 50px rgba(0, 0, 0, 0.5);
  animation: slideUp 300ms ease;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.closeButton {
  position: absolute;
  top: var(--space-md);
  right: var(--space-md);
  background: none;
  border: none;
  color: var(--neon-pink);
  font-size: 1.5rem;
  cursor: pointer;
  transition: transform var(--transition-fast), text-shadow var(--transition-fast);
}

.closeButton:hover {
  transform: scale(1.1);
  text-shadow: var(--glow-pink);
}

.title {
  font-family: var(--font-display);
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  margin-bottom: var(--space-lg);
  padding-right: var(--space-xl);
}

.content {
  color: white;
}
```

**Step 3: Commit**
```bash
git add src/components/ui/Modal.tsx src/components/ui/Modal.module.css && git commit -m "feat: create Modal component with neon styling"
```

---

### Task 16: Create RentalTimer component

**File:** `src/components/ui/RentalTimer.tsx`

**Step 1: Write component**
```tsx
import { useState, useEffect } from 'react';
import styles from './RentalTimer.module.css';

interface RentalTimerProps {
  expiresAt: number;
  compact?: boolean;
}

function formatTimeRemaining(ms: number): string {
  if (ms <= 0) return 'Expir√©';

  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) {
    return `${days}j ${hours % 24}h ${minutes % 60}m`;
  }
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
}

function getUrgencyLevel(ms: number): 'normal' | 'warning' | 'urgent' | 'critical' {
  const hours = ms / (1000 * 60 * 60);
  if (hours < 1) return 'critical';
  if (hours < 6) return 'urgent';
  if (hours < 24) return 'warning';
  return 'normal';
}

export function RentalTimer({ expiresAt, compact = false }: RentalTimerProps) {
  const [remaining, setRemaining] = useState(expiresAt - Date.now());

  useEffect(() => {
    const interval = setInterval(() => {
      setRemaining(expiresAt - Date.now());
    }, 1000);

    return () => clearInterval(interval);
  }, [expiresAt]);

  const urgency = getUrgencyLevel(remaining);

  return (
    <div className={`${styles.timer} ${styles[urgency]} ${compact ? styles.compact : ''}`}>
      <span className={styles.icon}>‚è±</span>
      <span className={styles.time}>{formatTimeRemaining(remaining)}</span>
    </div>
  );
}
```

**File:** `src/components/ui/RentalTimer.module.css`

**Step 2: Write styles**
```css
.timer {
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
  font-family: var(--font-display);
  padding: var(--space-xs) var(--space-sm);
  border-radius: 4px;
  background: rgba(0, 0, 0, 0.5);
}

.compact {
  font-size: 0.75rem;
  padding: 2px var(--space-xs);
}

.icon {
  font-size: 0.9em;
}

.time {
  letter-spacing: 0.05em;
}

.normal {
  color: rgba(255, 255, 255, 0.7);
}

.warning {
  color: orange;
}

.urgent {
  color: #ff6b6b;
  animation: pulse 1s infinite;
}

.critical {
  color: #ff2d2d;
  animation: blink 0.5s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
```

**Step 3: Commit**
```bash
git add src/components/ui/RentalTimer.tsx src/components/ui/RentalTimer.module.css && git commit -m "feat: create RentalTimer component with urgency levels"
```

---

## Continuing in next section...

The plan continues with:
- Task 17-20: FilmDetailModal, MesLocations, NavigationControls
- Task 21-25: Manager components (Avatar, Chat, SpeechBubble, BellButton, triggers hook)
- Task 26-30: VHS Player components
- Task 31-35: WebGPU scenes and objects
- Task 36-40: Integration and final assembly

See `docs/plans/2026-01-30-videoclub-2.0-implementation-part2.md` for continuation.
