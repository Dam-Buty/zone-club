# Session du 3 Février 2026 - Video Club WebGPU

## Résumé des travaux effectués

### 1. Modèle Pulp Fiction à l'entrée

**Objectif :** Remplacer le modèle Catwoman par Pulp Fiction à l'entrée du magasin, avant la section Thriller.

**Modifications :**
- Position finale: `[-ROOM_WIDTH / 2 + 0.45, 0, 3.33]`
- Scale: `0.05`
- Rotation: `[0, Math.PI, 0]` (face au manager)

**Fichiers modifiés :**
- `src/components/interior/Aisle.tsx`

### 2. Spot Light au-dessus de Pulp Fiction

**Objectif :** Ajouter un éclairage chaleureux qui met en valeur le modèle.

**Implémentation :**
- Modèle 3D `spot_light.glb` positionné au-dessus
- Position: `[-ROOM_WIDTH / 2 + 0.15, 1.575, 3.33]`
- Scale: `0.3`
- Rotation: `[0, 0, -Math.PI / 12]` (incliné vers le bas)

**Lumière chaude :**
```typescript
<pointLight
  position={[-ROOM_WIDTH / 2 + 0.15, 1.55, 3.33]}
  color="#ffaa66"
  intensity={6.4}
  distance={2.5}
  decay={2.5}
/>
```

**Note :** Le SpotLight de drei causait une erreur ("mesh.current.parent.target.getWorldPosition is not a function"). Remplacé par un simple pointLight.

### 3. Repositionnement sections Thriller/Horreur

**Objectif :** Décaler les sections Thriller et Horreur de 10-15% vers le fond du vidéoclub.

**Modifications :**
- `THRILLER_SECTION_Z`: décalé vers le fond
- `HORROR_SECTION_Z`: décalé vers le fond
- Panneaux de genre correspondants ajustés

### 4. Optimisations Performance (Focus principal)

#### 4.1 Éclairage (`Lighting.tsx`)

**Problème :** 21 lumières (9 RectAreaLights au plafond + autres) = trop de calculs.

**Solution :** Mode optimisé avec 8 lumières seulement.

```typescript
const LIGHTING_MODE: 'full' | 'optimized' = 'optimized'

function OptimizedLighting() {
  return (
    <>
      <ambientLight intensity={0.25} color="#fff8f0" />
      <hemisphereLight color="#fff8f0" groundColor="#4a4a5a" intensity={0.2} />
      {/* UNE RectAreaLight au lieu de 9 */}
      <rectAreaLight width={10} height={8} intensity={1.2} ... />
      <pointLight position={[3.5, 2.4, 2.8]} intensity={1} ... /> {/* manager */}
      <pointLight position={[-0.8, 2.4, 0]} intensity={0.8} ... /> {/* îlot */}
      {/* 3 RectAreaLights vitrine/porte */}
    </>
  )
}
```

**Gain :** -62% de lumières (21 → 8)

#### 4.2 Raycast Throttling (`Controls.tsx`)

**Problème :** Raycast à 60 fps = CPU inutilement sollicité.

**Solution :** Raycast toutes les 2 frames.

```typescript
const frameCountRef = useRef(0)
const RAYCAST_INTERVAL = 2

useFrame((_, delta) => {
  frameCountRef.current++
  const shouldRaycast = frameCountRef.current % RAYCAST_INTERVAL === 0

  if (controlsRef.current?.isLocked && shouldRaycast) {
    // Raycast logic
  }
})
```

**Gain :** -50% CPU raycast (60 → 30 raycast/sec)

#### 4.3 Géométrie partagée (`Cassette.tsx`)

**Problème :** ~520 cassettes, chacune avec sa propre BoxGeometry = mémoire gaspillée.

**Solution :** Une seule géométrie partagée par toutes les cassettes.

```typescript
// Créée une seule fois, hors du composant
const SHARED_CASSETTE_GEOMETRY = new THREE.BoxGeometry(
  CASSETTE_WIDTH,
  CASSETTE_HEIGHT,
  CASSETTE_DEPTH
)

// Dans le composant
<mesh geometry={SHARED_CASSETTE_GEOMETRY}>
  <meshStandardMaterial ... />
</mesh>
```

**Gain :** -99% mémoire géométrie (520 → 1 BoxGeometry)

#### 4.4 React.memo avec comparaison custom

**Problème :** Re-renders inutiles des cassettes.

**Solution :** Comparaison explicite des props qui changent vraiment.

```typescript
export const Cassette = memo(function Cassette(...) {
  // ...
}, (prevProps, nextProps) => {
  return (
    prevProps.cassetteKey === nextProps.cassetteKey &&
    prevProps.film.id === nextProps.film.id &&
    prevProps.film.poster_path === nextProps.film.poster_path &&
    prevProps.position[0] === nextProps.position[0] &&
    prevProps.position[1] === nextProps.position[1] &&
    prevProps.position[2] === nextProps.position[2] &&
    prevProps.hoverOffsetZ === nextProps.hoverOffsetZ
  )
})
```

#### 4.5 Disposal des textures/matériaux

**Problème :** Textures et matériaux non libérés au unmount = memory leaks.

**Solution :** Cleanup dans useEffect.

```typescript
useEffect(() => {
  return () => {
    if (texture) texture.dispose()
    if (materialRef.current) materialRef.current.dispose()
  }
}, [texture])
```

#### 4.6 Frustum Culling pour animations

**Problème :** Toutes les 520 cassettes animent leur useFrame, même hors champ.

**Solution :** Skip animation si cassette hors du frustum de la caméra.

```typescript
// Réutilisables (hors composant pour éviter allocations)
const frustum = new THREE.Frustum()
const projScreenMatrix = new THREE.Matrix4()
const tempWorldPos = new THREE.Vector3()

useFrame(({ camera }) => {
  // Mise à jour frustum une seule fois par frame
  if (lastFrustumFrame !== globalFrameCount) {
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
    frustum.setFromProjectionMatrix(projScreenMatrix)
    lastFrustumFrame = globalFrameCount
  }

  // Skip si hors champ
  meshRef.current.getWorldPosition(tempWorldPos)
  if (!frustum.containsPoint(tempWorldPos)) return

  // Animation...
})
```

**Gain :** -80% animations (seules les cassettes visibles animent)

#### 4.7 Shadows désactivés sur cassettes

**Problème :** `castShadow={true}` sur 520 cassettes = 520 shadow renders.

**Solution :** Désactiver les shadows sur les cassettes.

```typescript
<mesh castShadow={false} ...>
```

**Gain :** -100% shadow renders sur cassettes

#### 4.8 Animation Throttling

**Problème :** Animations à 60 fps non nécessaires.

**Solution :** Animer toutes les 2 frames.

```typescript
let globalFrameCount = 0
const ANIMATION_THROTTLE = 2

useFrame(() => {
  if (globalFrameCount % ANIMATION_THROTTLE !== 0) return
  // Animation...
})
```

### 5. Instancing - Approche abandonnée

**Idée :** Utiliser InstancedMesh pour les cassettes.

**Problème :** Chaque cassette a une texture TMDB unique (poster). L'instancing ne fonctionne qu'avec des instances identiques ou des variations de couleur/transformation.

**Conclusion :** Instancing ne convient pas pour des objets avec textures uniques par instance.

---

## Métriques d'optimisation

| Optimisation | Avant | Après | Gain |
|--------------|-------|-------|------|
| Lumières | 21 | 8 | -62% |
| Raycast/sec | 60 | 30 | -50% |
| BoxGeometry | 520 | 1 | -99% |
| Animations/frame | 520 | ~50-100 | -80% |
| Shadow renders cassettes | 520 | 0 | -100% |

---

## Erreurs rencontrées et solutions

| Erreur | Cause | Solution |
|--------|-------|----------|
| `spot-light.glb` not found | Typo dans le nom | Utiliser `spot_light.glb` |
| drei SpotLight crash | Target.getWorldPosition not a function | Remplacer par pointLight |
| Éclairage trop clair/moche | Intensités non ajustées | Réduire intensités (0.25, 0.2, 1.2...) |
| new Vector3() chaque frame | Allocations dans useFrame | Variables réutilisables hors composant |
| Raycast reset cassant ciblage | else block reset même quand skip | Séparer logique de reset |

---

## Fichiers modifiés

| Fichier | Modifications |
|---------|--------------|
| `Aisle.tsx` | Pulp Fiction, spot light, sections repositionnées |
| `Lighting.tsx` | Mode optimisé 8 lumières |
| `Controls.tsx` | Raycast throttling |
| `Cassette.tsx` | Géométrie partagée, memo, disposal, frustum culling, animation throttle |
| `CLAUDE.md` | Documentation optimisations |

---

## État du projet

- Modèle Pulp Fiction à l'entrée avec éclairage chaleureux
- Performance optimisée pour configurations modestes
- Mode d'éclairage configurable (full/optimized)
- ~520 cassettes avec animations efficientes
